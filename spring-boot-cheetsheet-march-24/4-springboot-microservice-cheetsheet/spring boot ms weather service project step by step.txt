Spring boot microserivice project:
===================================
Weatherservice and weatherclient application

used tech:
spring boot & Spring cloud

Step 1: Configure eureaka server
Step 2: Create Weatherservice application
Step 3: Create weatherclient application
Step 4: adding resilence4j to weatherclient application
Step 5: Create spring cloud gateway server configuration
Step 6: Understanding Concept of filter and interceptor spring boot
Step 7: Applying custom interceptor with spring cloud config server
Step 8: Applying security to spring cloud gateway


Spring boot tools and technologies:
----------------------------
* Eureka server
* Open Feign
* Ribbon/Spring cloud load balancer
* Hystric/Resilence4j
* Zuul api gateway/ spring cloud gateway
* Spring cloud config server 
* ELK
* Spring boot grafana and prometheus
* Sluth and zipkin



Ports:
------
weatherclient: 8085
Weatherservice: 8082, 8083
eureaka:8761
api gateway: 8080
auth server: 9090
config server: 8888

urls:
------
http://localhost:8761
http://localhost:8761/eureka/apps


spring boot logging
==================
Disable logging :
---------------
logging.level.root=OFF
logging.level.org.springframework.boot=OFF
spring.main.banner-mode=OFF   
    
Customizing logging :
---------------	     
logging.level.com.productapp=info

logging.level.org.springframework.web: DEBUG
logging.level.org.hibernate: ERROR

logging.file.name=/home/raj/Desktop/logs/server.log


Spring boot actuator
====================
management.endpoints.web.exposure.include=*
management.endpoints.jmx.exposure.include=*
management.endpoints.web.base-path=/productapp
management.endpoint.shutdown.enabled=true
management.endpoint.health.show-details= always

URL
-------------------
eureka:
http://localhost:8761
http://localhost:8761/eureka/apps

Weatherservice:
http://localhost:8082/wservice/weatherinfo/24

weatherclient:
http://localhost:8085/wclient/weatherclient/24

Observe the circuitbreakers:
http://localhost:8085/wclient/actuator/health

Calling with api gateway:
http://localhost:8080/wclient/weatherclient/24



Step 1: create eureaka:8761
----------------------------
apply annotation on config class

@EnableEurekaServer

application.yml
---------------
server:
  port: 8761
spring:
  application:
    name: eureka-server
eureka:
  instance:
    prefer-ip-address: true
  client:
    register-with-eureka: false
    fetch-registry: false
    service-url:
      defaultZone: http://localhost:8761/eureka/






Step 2: create Weatherservice project 
---------------------------------------
choose : web, eureaka client,actuator

@Service
public class WeatherService {

    @Value("${server.port}")
    private int  portNumber;

    public String getWeatherInfo(int temp){
        String weatherInfo="";
        if(temp>=40)
            weatherInfo="too hot to go outside";
        else if (temp >= 30)
            weatherInfo="ok to go outside but take care";
        else if (temp >= 18)
            weatherInfo="why not go outside and enjoy";
        else
            weatherInfo="too cold to go outside";

        return weatherInfo+ ": "+portNumber;
    }
}

@RestController
public class WeatherServiceController {

    @Autowired
    private WeatherService weatherService;

    @GetMapping(path="weatherinfo/{temp}")
    public String getWeatherInfo(@PathVariable int temp){
        return weatherService.getWeatherInfo(temp);
    }
}


server:
  port: 8082
  servlet:
    context-path: /wservice
spring:
  application:
    name: weather-service
eureka:
  instance:
    prefer-ip-address: true
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://localhost:8761/eureka/
management:
  endpoints:
    web:
      exposure:
        include: "*"

		

running endpoint
-----------------
http://localhost:8082/wservice/weatherinfo/24





Step 3: create Weatherclient project 
---------------------------------------
choose : web, eureaka client,actuator


@RestController
public class WeatherServiceClientController {
    @Autowired
    private WeatherClientService weatherClientService;

    @GetMapping(path = "weatherclient/{temp}")
    public String weatherClient(@PathVariable int temp){
        return "client :"+  weatherClientService.getWeatherInfo(temp);
    }

}

@Service
public class WeatherClientService {

	@LoadBalanced
    @Autowired
    private RestTemplate restTemplate;

    public String getWeatherInfo(int temp){
    
       return restTemplate.getForObject("http://WEATHER-SERVICE/wservice/weatherinfo/"+ temp, String.class);
    }
}

server:
  port: 8085
  servlet:
    context-path: /wclient
spring:
  application:
    name:  weather-client
eureka:
  instance:
    prefer-ip-address: true
  client:
    registry-fetch-interval-seconds: 10
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://localhost:8761/eureka/


running endpoint:
------------------
http://localhost:8085/wclient/weatherclient/24






Step 4: Applying resilance4j: fault tolerence
---------------------------------------
add :resilance4j to wclient application

fallback logic:
-----------------


    @CircuitBreaker(fallbackMethod = "fallBackLogic", name = "weatherservice")
    @GetMapping(path = "weatherclient/{temp}")
    public String weatherClient(@PathVariable int temp){
        return "client :"+  weatherClientService.getWeatherInfo(temp);
    }

    public String fallBackLogic(Exception e){
        System.out.println("****************************");
        System.out.println(e);
        System.out.println("****************************");
        return "weather is ok ok";
    }



#eureka.client.registryFetchIntervalSeconds=5

resilience4j:
  circuitbreaker:
    instances:
      weatherservice:
        register-health-indicator: true
        event-consumer-buffer-size: 10
        failure-rate-threshold: 50
        minimum-number-of-calls: 5
        automatic-transition-from-open-to-half-open-enabled: true
        wait-duration-in-open-state: 5s
        permitted-number-of-calls-in-half-open-state: 3
        sliding-window-size: 10
        sliding-window-type: count_based

management:
  endpoints:
    web:
      exposure:
        include: health
  health:
    circuitbreakers:
      enabled: true
  endpoint:
    health:
      show-details: always


Observe the circuitbreakers design pattern:

http://localhost:8085/wclient/actuator/health






Step 5: Spring cloud gateway (Zuul api gateway is deprecated )
-----------------------------------------------------------
Create a project with dependencies
Choose : eureka client, actuator, gateway (check for maven repo)

<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
		
Apply annotation :@EnableDiscoveryClient


application.yml
-----------------
server:
  port: 8099
spring:
  application:
    name: apigateway-server
  cloud:
    gateway:
      routes:
        - id: wservice-id
          uri: lb://WEATHER-SERVICE
          predicates:
            - Path=/wservice/**

        - id: wclient-id
          uri: lb://WEATHER-CLIENT
          predicates:
            - Path=/wclient/**
        
eureka:
  client:
    registry-fetch-interval-seconds: 10
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://localhost:8761/eureka/


	  
	  
	  
Step 6: Understanding Concept of filter and interceptor spring boot
---------------------------------------------------------------------
https://www.baeldung.com/spring-mvc-handlerinterceptor-vs-filter

Understanding filter and interceptor
-------------------------------

@RestController
public class HelloController {

    @GetMapping(path = "hello")
    public String hello(){
        return "hello endpoint";
    }

    @GetMapping(path = "hello2")
    public String hello2(){
        return "hello2 endpoint";
    }

    @GetMapping(path = "hello2/pqr")
    public String hello2Nested2(){
        return "hello2/pqr endpoint";
    }

    @GetMapping(path = "hello2/bca")
    public String hello2Nested(){
        return "hello2/bca endpoint";
    }

    @GetMapping(path = "hello3")
    public String hello3(){
        return "hello3 endpoint";
    }

}


@Component
@Order(1)
public class Filter1 implements Filter {
    public Filter1() {
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        Filter.super.init(filterConfig);
        System.out.println("init is called filter 1");
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)
            throws IOException, ServletException {

        System.out.println("i am running with every request...filter 1");
        HttpServletRequest req= (HttpServletRequest) servletRequest;

        String uri=req.getRequestURI();
        System.out.println("uri req: "+ uri);
        filterChain.doFilter(servletRequest, servletResponse);
    }

    @Override
    public void destroy() {
        System.out.println("dest is called filter1");
    }
}

@Configuration
public class FilterConfig {
    //u need to register the filter with spring mvc
   // FilterRegistrationBean
    @Bean
    public FilterRegistrationBean<Filter1> regiserFilter1(){
        FilterRegistrationBean<Filter1> registrationBeans=new FilterRegistrationBean<Filter1>();
        registrationBeans.setFilter(new Filter1());
        registrationBeans.addUrlPatterns("/hello2/*");//Why it is running for all api endpoints
        return registrationBeans;
    }
}


@Component
public class GenericInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(
            HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // You can do your processing here
        System.out.println("GenericInterceptor preHandle is called");
        return true;
    }
    @Override
    public void postHandle(
            HttpServletRequest request, HttpServletResponse response, Object handler,
            ModelAndView modelAndView) throws Exception {
        System.out.println("GenericInterceptor postHandle is called");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                                Object handler, Exception exception) throws Exception {
        System.out.println("GenericInterceptor afterCompletion is called");
    }
}


@Component
public class SpecificInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(
            HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // You can do your processing here
        System.out.println("SpecificInterceptor preHandle is called");
        return true;
    }
    @Override
    public void postHandle(
            HttpServletRequest request, HttpServletResponse response, Object handler,
            ModelAndView modelAndView) throws Exception {
        System.out.println("SpecificInterceptor postHandle is called");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                                Object handler, Exception exception) throws Exception {
        System.out.println("SpecificInterceptor afterCompletion is called");
    }
}


@Configuration
public class InterceptorConfig implements WebMvcConfigurer {

    @Autowired
    private SpecificInterceptor specificInterceptor;

    @Autowired
    private GenericInterceptor genericInterceptor;


    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //i need to register my intercepor

        registry.addInterceptor(genericInterceptor).order(1);
        registry.addInterceptor(specificInterceptor)
                .addPathPatterns("/hello2/**")
                .order(2)
                .excludePathPatterns("/hello2/pqr");

    }
}


Now run spring security authserver project and try endpoints
-------------------------------------------------------------
register new user:
http://localhost:9092/authserver/register

Authenticate new user get token for new user:
http://localhost:9092/authserver/authenticate

now try to validate the token:
-----------------------------
http://localhost:9092/authserver/validate?token=eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJmb28iLCJpYXQiOjE3MDk2MTMwNTMsImV4cCI6MTcwOTYxNDg1M30.qijj-HbAzD4i0Dj2-cATDpfo_6VGmpBsv_8GXXOAobQ


Creating global filter for spring cloud gateway:
----------------------------------------
2 kind of filter that u can use with api gateway , reactive way of programming
* global filter
* filter for specific routes: AbstractGatewayFilterFactory


Apply GlobalFilter with api gateway, no need to config in yaml file
-------------------------------------------------------------------
@Component
public class MyGlobalFiter implements GlobalFilter , Ordered {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        System.out.println("------------inside global fiter of api gateway-----------------");
         var requestWithHeader= exchange.getRequest().mutate()
                .header("weatherappfilter1","weather app global fitler value")
                .build();
        return chain.filter(exchange.mutate().request(requestWithHeader).build());
    }

    @Override
    public int getOrder() {
        return -1;
    }
}


Now we are going to accept "weatherapifilter" header in any microservice:

  @GetMapping(path = "weatherclient/{temp}")
    public String weatherClient(@PathVariable int temp, @RequestHeader(name = "weatherapifilter") String weatherapifilter){
        System.out.println("---------------------------------");
        System.out.println(weatherapifilter);
    }



Applying custom interceptor with spring cloud config server
------------------------------------------------------------
@Service
public class WeatherAppPreFilter extends AbstractGatewayFilterFactory<WeatherAppPreFilter.Config> {

    public WeatherAppPreFilter(){
        super(Config.class);
    }
    @Override
    public GatewayFilter apply(Config config) {
        return ( exchange,  chain)-> {
                System.out.printf("*****WeatherAppPreFilter******");
            var requestWithHeader= exchange.getRequest().mutate()
                    .header("myheader","this is some sec token")
                    .build();
                return chain.filter(exchange.mutate().request(requestWithHeader).build());
        };
    }

    public static class Config{
    }
}

With filter for specific routes: AbstractGatewayFilterFactory filter:
---------------          
server:
  port: 8099
spring:
  application:
    name: apigateway-server
  cloud:
    gateway:
      routes:
        - id: wservice-id
          uri: lb://WEATHER-SERVICE
          predicates:
            - Path=/wservice/**
          filters:
            - name: WeatherAppPreFilter

        - id: wclient-id
          uri: lb://WEATHER-CLIENT
          predicates:
            - Path=/wclient/**
          filters:
            - name: WeatherAppPreFilter
eureka:
  client:
    registry-fetch-interval-seconds: 10
    register-with-eureka: true
    fetch-registry: true
    service-url:
      defaultZone: http://localhost:8761/eureka/






Step 8: Applying security to spring cloud gateway
            
            